# Docling Thai OCR Research Report

## Executive Summary

This report analyzes the feasibility of using [Docling](https://github.com/docling-project/docling) to extract information from Thai financial documents in the Y67 directory for backend application and AI agent use.

**Key Findings:**
- Docling supports Thai OCR via EasyOCR (language code: `th`)
- 466 PDF files across 11 Thai companies with multi-year financial data
- Structured document types enable reliable schema design
- Relational database storage is feasible and recommended

---

## 1. Docling Capabilities Analysis

### 1.1 Core Features
| Feature | Support | Notes |
|---------|---------|-------|
| PDF Processing | ✅ | Native support with layout analysis |
| Thai OCR | ✅ | Via EasyOCR with `lang=["th", "en"]` |
| Table Extraction | ✅ | TableFormer with ACCURATE mode |
| JSON Export | ✅ | Lossless JSON, Markdown, HTML |
| Batch Processing | ✅ | Multiple files supported |

### 1.2 Thai Language Support
Docling uses [EasyOCR](https://github.com/JaidedAI/EasyOCR) which supports 80+ languages including Thai:
- Language code: `th`
- Can combine with English: `["th", "en"]`
- Thai character set fully supported

### 1.3 Configuration for Thai Documents

```python
from docling.document_converter import DocumentConverter, PdfFormatOption
from docling.datamodel.base_models import InputFormat
from docling.datamodel.pipeline_options import (
    PdfPipelineOptions,
    EasyOcrOptions,
    TableFormerMode,
)

# Configure for Thai financial documents
pipeline_options = PdfPipelineOptions()
pipeline_options.do_ocr = True
pipeline_options.do_table_structure = True

# Thai + English OCR
pipeline_options.ocr_options = EasyOcrOptions(
    lang=["th", "en"],
    confidence_threshold=0.5
)

# Accurate table extraction for financial data
pipeline_options.table_structure_options.mode = TableFormerMode.ACCURATE

converter = DocumentConverter(
    format_options={
        InputFormat.PDF: PdfFormatOption(pipeline_options=pipeline_options)
    }
)
```

---

## 2. Y67 Directory Analysis

### 2.1 Structure Overview
```
Y67/
├── {company_id} {company_name_thai}/
│   ├── Y58/
│   │   ├── {company_name}_BS58.pdf
│   │   ├── {company_name}_Compare BS.pdf
│   │   ├── {company_name}_Compare PL.pdf
│   │   ├── {company_name}_Gen Info.pdf
│   │   ├── {company_name}_Ratio.pdf
│   │   ├── {company_name}_Related.pdf
│   │   └── {company_name}_Shareholders.pdf
│   ├── Y59/
│   ├── Y61/
│   ├── Y62/
│   ├── Y63/
│   ├── Y66/
│   └── Y67/
│       └── ... (additional: Cash Flow.pdf, Others.pdf)
```

### 2.2 Statistics
| Metric | Value |
|--------|-------|
| Total Companies | 11 |
| Total PDF Files | 466 |
| Total Directories | 73 |
| Fiscal Years | Y58-Y67 (2015-2024 BE) |
| Avg Files per Company | ~42 |

### 2.3 Company List
| Company ID | Company Name |
|------------|--------------|
| 10000588 | บริษัท สโตเรจซิสเต็ม อินดัสตรี จำกัด |
| 10002819 | บริษัท โฮชุง อินดัสเตรียล (ประเทศไทย) จำกัด |
| 10003232 | บริษัท เปี๊ยกจังเกิ้ล ออฟโรด จำกัด |
| 10004027 | บริษัท พิรุฬห์ แอสเซมบลีย์ จำกัด |
| 10004367 | บริษัท ใบตาล เทอร์บายน์ จำกัด |
| 10005052 | บริษัท ยงยุทธ ก่อสร้างและ การโยธา (2499) จำกัด |
| 10005674 | บริษัท ภัทรมารีน จำกัด |
| 10006366 | บริษัท พาวเวอร์เมคซิสเท็ม จำกัด |
| 10006868 | บริษัท วัฒนาวิชั่นกรุ๊ป จำกัด |
| 10006995 | บริษัท ไทจีนิค จำกัด |
| 10007090 | บริษัท ไทยนิยม อินเตอร์โปรดักส์ จำกัด |

### 2.4 Document Types
| Code | Description | Content Type |
|------|-------------|--------------|
| BS{YY} | Balance Sheet | Financial tables |
| Compare BS | Balance Sheet Comparison | Comparative tables |
| Compare PL | Profit & Loss Comparison | Comparative tables |
| Cash Flow | Cash Flow Statement | Financial tables |
| Gen Info | General Information | Key-value pairs, text |
| Ratio | Financial Ratios | Calculated metrics |
| Related | Related Party Info | Relationship data |
| Shareholders | Shareholder Info | Ownership tables |
| Others | Miscellaneous | Mixed content |

---

## 3. Database Schema Design

### 3.1 Entity Relationship Diagram

```
┌─────────────┐       ┌──────────────┐       ┌─────────────┐
│  companies  │──────<│ fiscal_years │──────<│  documents  │
└─────────────┘       └──────────────┘       └─────────────┘
                                                    │
                      ┌─────────────────────────────┼─────────────────────────────┐
                      │                             │                             │
                      ▼                             ▼                             ▼
              ┌───────────────┐            ┌───────────────┐            ┌─────────────────┐
              │ extracted_text│            │extracted_tables│            │ document_items  │
              └───────────────┘            └───────────────┘            └─────────────────┘
                                                   │
                                                   ▼
                                          ┌───────────────┐
                                          │  table_cells  │
                                          └───────────────┘
```

### 3.2 Table Definitions

```sql
-- Companies master table
CREATE TABLE companies (
    id SERIAL PRIMARY KEY,
    company_code VARCHAR(20) UNIQUE NOT NULL,  -- e.g., "10002819"
    company_name_th TEXT NOT NULL,
    company_name_en TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Fiscal years per company
CREATE TABLE fiscal_years (
    id SERIAL PRIMARY KEY,
    company_id INTEGER REFERENCES companies(id) ON DELETE CASCADE,
    fiscal_year INTEGER NOT NULL,  -- Buddhist Era year (e.g., 2567)
    fiscal_year_code VARCHAR(10),  -- e.g., "Y67"
    start_date DATE,
    end_date DATE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(company_id, fiscal_year)
);

-- Document metadata and processing status
CREATE TABLE documents (
    id SERIAL PRIMARY KEY,
    fiscal_year_id INTEGER REFERENCES fiscal_years(id) ON DELETE CASCADE,
    document_type VARCHAR(50) NOT NULL,  -- BS, Compare BS, Gen Info, etc.
    file_path TEXT NOT NULL,
    file_name TEXT NOT NULL,
    file_size_bytes BIGINT,
    page_count INTEGER,
    processing_status VARCHAR(20) DEFAULT 'pending',  -- pending, processing, completed, failed
    processing_started_at TIMESTAMP,
    processing_completed_at TIMESTAMP,
    error_message TEXT,
    docling_version VARCHAR(20),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(fiscal_year_id, document_type)
);

-- Full text content extracted from documents
CREATE TABLE extracted_text (
    id SERIAL PRIMARY KEY,
    document_id INTEGER REFERENCES documents(id) ON DELETE CASCADE,
    page_number INTEGER,
    content_type VARCHAR(50),  -- paragraph, header, list_item, etc.
    text_content TEXT NOT NULL,
    confidence_score DECIMAL(5,4),
    bounding_box JSONB,  -- {x, y, width, height}
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Tables extracted from documents
CREATE TABLE extracted_tables (
    id SERIAL PRIMARY KEY,
    document_id INTEGER REFERENCES documents(id) ON DELETE CASCADE,
    page_number INTEGER,
    table_index INTEGER,  -- Order on page
    table_type VARCHAR(50),  -- balance_sheet, income_statement, cash_flow, etc.
    row_count INTEGER,
    column_count INTEGER,
    headers JSONB,  -- Array of column headers
    raw_data JSONB,  -- Full table as JSON
    markdown_content TEXT,  -- Table as markdown
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Individual table cells for granular querying
CREATE TABLE table_cells (
    id SERIAL PRIMARY KEY,
    table_id INTEGER REFERENCES extracted_tables(id) ON DELETE CASCADE,
    row_index INTEGER NOT NULL,
    column_index INTEGER NOT NULL,
    cell_value TEXT,
    cell_type VARCHAR(20),  -- text, number, date, empty
    numeric_value DECIMAL(20,4),  -- Parsed numeric value if applicable
    is_header BOOLEAN DEFAULT FALSE,
    confidence_score DECIMAL(5,4),
    UNIQUE(table_id, row_index, column_index)
);

-- Normalized financial metrics for easy querying
CREATE TABLE financial_metrics (
    id SERIAL PRIMARY KEY,
    fiscal_year_id INTEGER REFERENCES fiscal_years(id) ON DELETE CASCADE,
    metric_category VARCHAR(50) NOT NULL,  -- assets, liabilities, equity, revenue, etc.
    metric_name TEXT NOT NULL,
    metric_name_en TEXT,
    metric_value DECIMAL(20,4),
    unit VARCHAR(20) DEFAULT 'THB',
    source_document_id INTEGER REFERENCES documents(id),
    source_table_id INTEGER REFERENCES extracted_tables(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Shareholder information
CREATE TABLE shareholders (
    id SERIAL PRIMARY KEY,
    fiscal_year_id INTEGER REFERENCES fiscal_years(id) ON DELETE CASCADE,
    shareholder_name TEXT NOT NULL,
    shareholder_type VARCHAR(50),  -- individual, corporate, government, etc.
    share_count BIGINT,
    share_percentage DECIMAL(8,4),
    nationality VARCHAR(50),
    source_document_id INTEGER REFERENCES documents(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Related party information
CREATE TABLE related_parties (
    id SERIAL PRIMARY KEY,
    fiscal_year_id INTEGER REFERENCES fiscal_years(id) ON DELETE CASCADE,
    party_name TEXT NOT NULL,
    relationship_type VARCHAR(100),
    transaction_type VARCHAR(100),
    transaction_amount DECIMAL(20,4),
    source_document_id INTEGER REFERENCES documents(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Processing job tracking
CREATE TABLE processing_jobs (
    id SERIAL PRIMARY KEY,
    job_type VARCHAR(50) NOT NULL,  -- full_scan, incremental, single_document
    status VARCHAR(20) DEFAULT 'pending',
    total_documents INTEGER,
    processed_documents INTEGER DEFAULT 0,
    failed_documents INTEGER DEFAULT 0,
    started_at TIMESTAMP,
    completed_at TIMESTAMP,
    error_log TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Indexes for performance
CREATE INDEX idx_documents_status ON documents(processing_status);
CREATE INDEX idx_documents_type ON documents(document_type);
CREATE INDEX idx_extracted_text_document ON extracted_text(document_id);
CREATE INDEX idx_extracted_tables_document ON extracted_tables(document_id);
CREATE INDEX idx_table_cells_table ON table_cells(table_id);
CREATE INDEX idx_financial_metrics_fiscal ON financial_metrics(fiscal_year_id);
CREATE INDEX idx_financial_metrics_category ON financial_metrics(metric_category);
CREATE INDEX idx_shareholders_fiscal ON shareholders(fiscal_year_id);

-- Full-text search on Thai content
CREATE INDEX idx_extracted_text_content ON extracted_text USING gin(to_tsvector('simple', text_content));
```

### 3.3 Schema Benefits for AI Agents

1. **Structured Financial Data**: `financial_metrics` table enables direct SQL queries for financial analysis
2. **Full-Text Search**: GIN index on `extracted_text` for semantic search
3. **Provenance Tracking**: Links back to source documents and tables
4. **Processing Status**: Track extraction progress and handle failures
5. **Normalized Data**: Consistent data types for numeric analysis

---

## 4. Implementation Plan

### Phase 1: Environment Setup (Day 1)
- [ ] Install Docling: `pip install docling[vlm]`
- [ ] Install Tesseract (optional backup): `brew install tesseract tesseract-lang`
- [ ] Set up PostgreSQL database
- [ ] Create database schema
- [ ] Verify Thai OCR with sample document

### Phase 2: OCR Pipeline Development (Days 2-3)
- [ ] Create document scanner to enumerate all PDFs
- [ ] Implement batch processing with progress tracking
- [ ] Configure EasyOCR for Thai+English
- [ ] Enable TableFormer ACCURATE mode
- [ ] Implement JSON export and parsing

### Phase 3: Data Extraction & Storage (Days 4-5)
- [ ] Parse company/year/document metadata from paths
- [ ] Extract and store text content
- [ ] Extract and store table structures
- [ ] Implement table cell parsing for numeric values
- [ ] Handle processing failures gracefully

### Phase 4: Data Normalization (Days 6-7)
- [ ] Create financial metric extraction rules
- [ ] Map Thai financial terms to standardized categories
- [ ] Populate `financial_metrics` table
- [ ] Extract shareholder information
- [ ] Extract related party information

### Phase 5: API & Integration (Days 8-10)
- [ ] Create REST API endpoints for data access
- [ ] Implement search functionality
- [ ] Add AI agent-friendly query endpoints
- [ ] Document API for backend integration

---

## 5. Sample Implementation Code

### 5.1 Document Scanner

```python
import os
import re
from pathlib import Path
from dataclasses import dataclass
from typing import List, Optional

@dataclass
class DocumentInfo:
    company_code: str
    company_name: str
    fiscal_year: int
    fiscal_year_code: str
    document_type: str
    file_path: str
    file_name: str

def parse_folder_name(folder_name: str) -> tuple[str, str]:
    """Extract company code and name from folder name."""
    match = re.match(r'^(\d+)\s+(.+)$', folder_name)
    if match:
        return match.group(1), match.group(2)
    return None, folder_name

def parse_fiscal_year(year_folder: str) -> tuple[int, str]:
    """Convert Y67 to 2567 Buddhist Era."""
    match = re.match(r'^Y(\d{2})$', year_folder)
    if match:
        year_suffix = int(match.group(1))
        # Buddhist Era: 25XX for recent years
        full_year = 2500 + year_suffix
        return full_year, year_folder
    return None, year_folder

def parse_document_type(file_name: str) -> str:
    """Extract document type from filename."""
    patterns = {
        r'_BS\d{2}\.pdf$': 'balance_sheet',
        r'_Compare BS\.pdf$': 'compare_balance_sheet',
        r'_Compare PL\.pdf$': 'compare_profit_loss',
        r'_Cash Flow\.pdf$': 'cash_flow',
        r'_Gen Info\.pdf$': 'general_info',
        r'_Ratio\.pdf$': 'financial_ratios',
        r'_Related\.pdf$': 'related_parties',
        r'_Shareholders\.pdf$': 'shareholders',
        r'_Others\.pdf$': 'others',
    }
    for pattern, doc_type in patterns.items():
        if re.search(pattern, file_name):
            return doc_type
    return 'unknown'

def scan_documents(base_path: str) -> List[DocumentInfo]:
    """Scan Y67 directory and return list of document info."""
    documents = []
    base = Path(base_path)

    for company_folder in base.iterdir():
        if not company_folder.is_dir() or company_folder.name.startswith('.'):
            continue

        company_code, company_name = parse_folder_name(company_folder.name)

        for year_folder in company_folder.iterdir():
            if not year_folder.is_dir():
                continue

            fiscal_year, year_code = parse_fiscal_year(year_folder.name)
            if fiscal_year is None:
                continue

            for pdf_file in year_folder.glob('*.pdf'):
                doc_type = parse_document_type(pdf_file.name)

                documents.append(DocumentInfo(
                    company_code=company_code,
                    company_name=company_name,
                    fiscal_year=fiscal_year,
                    fiscal_year_code=year_code,
                    document_type=doc_type,
                    file_path=str(pdf_file),
                    file_name=pdf_file.name
                ))

    return documents
```

### 5.2 OCR Processor

```python
from docling.document_converter import DocumentConverter, PdfFormatOption
from docling.datamodel.base_models import InputFormat
from docling.datamodel.pipeline_options import (
    PdfPipelineOptions,
    EasyOcrOptions,
    TableFormerMode,
)
import json

class ThaiDocumentProcessor:
    def __init__(self):
        pipeline_options = PdfPipelineOptions()
        pipeline_options.do_ocr = True
        pipeline_options.do_table_structure = True

        # Thai + English OCR
        pipeline_options.ocr_options = EasyOcrOptions(
            lang=["th", "en"],
            confidence_threshold=0.5
        )

        # Accurate table extraction
        pipeline_options.table_structure_options.mode = TableFormerMode.ACCURATE

        self.converter = DocumentConverter(
            format_options={
                InputFormat.PDF: PdfFormatOption(pipeline_options=pipeline_options)
            }
        )

    def process_document(self, file_path: str) -> dict:
        """Process a single document and return structured data."""
        result = self.converter.convert(file_path)

        # Export to dictionary
        doc_dict = result.document.export_to_dict()

        # Extract tables to DataFrames
        tables = []
        doc = result.document
        for idx, table in enumerate(doc.tables):
            df = table.export_to_dataframe(doc=doc)
            tables.append({
                'index': idx,
                'rows': len(df),
                'columns': len(df.columns),
                'headers': list(df.columns),
                'data': df.to_dict('records'),
                'markdown': df.to_markdown()
            })

        return {
            'status': str(result.status),
            'page_count': result.input.page_count if hasattr(result.input, 'page_count') else None,
            'document': doc_dict,
            'tables': tables,
            'markdown': result.document.export_to_markdown()
        }
```

### 5.3 Database Storage

```python
import psycopg2
from psycopg2.extras import execute_values
import json

class DocumentStorage:
    def __init__(self, connection_string: str):
        self.conn = psycopg2.connect(connection_string)

    def store_document(self, doc_info: DocumentInfo, processed_data: dict):
        """Store processed document data in database."""
        with self.conn.cursor() as cur:
            # Upsert company
            cur.execute("""
                INSERT INTO companies (company_code, company_name_th)
                VALUES (%s, %s)
                ON CONFLICT (company_code) DO UPDATE SET company_name_th = EXCLUDED.company_name_th
                RETURNING id
            """, (doc_info.company_code, doc_info.company_name))
            company_id = cur.fetchone()[0]

            # Upsert fiscal year
            cur.execute("""
                INSERT INTO fiscal_years (company_id, fiscal_year, fiscal_year_code)
                VALUES (%s, %s, %s)
                ON CONFLICT (company_id, fiscal_year) DO NOTHING
                RETURNING id
            """, (company_id, doc_info.fiscal_year, doc_info.fiscal_year_code))
            result = cur.fetchone()
            if result:
                fiscal_year_id = result[0]
            else:
                cur.execute("""
                    SELECT id FROM fiscal_years
                    WHERE company_id = %s AND fiscal_year = %s
                """, (company_id, doc_info.fiscal_year))
                fiscal_year_id = cur.fetchone()[0]

            # Insert document
            cur.execute("""
                INSERT INTO documents (
                    fiscal_year_id, document_type, file_path, file_name,
                    page_count, processing_status, processing_completed_at
                )
                VALUES (%s, %s, %s, %s, %s, 'completed', NOW())
                ON CONFLICT (fiscal_year_id, document_type) DO UPDATE SET
                    processing_status = 'completed',
                    processing_completed_at = NOW()
                RETURNING id
            """, (
                fiscal_year_id, doc_info.document_type, doc_info.file_path,
                doc_info.file_name, processed_data.get('page_count')
            ))
            document_id = cur.fetchone()[0]

            # Store tables
            for table in processed_data.get('tables', []):
                cur.execute("""
                    INSERT INTO extracted_tables (
                        document_id, table_index, row_count, column_count,
                        headers, raw_data, markdown_content
                    )
                    VALUES (%s, %s, %s, %s, %s, %s, %s)
                    RETURNING id
                """, (
                    document_id, table['index'], table['rows'], table['columns'],
                    json.dumps(table['headers']), json.dumps(table['data']),
                    table['markdown']
                ))

            self.conn.commit()
            return document_id
```

---

## 6. Considerations & Recommendations

### 6.1 Thai OCR Accuracy
- EasyOCR performs well on printed Thai text
- Financial documents typically use standardized formats
- Consider post-processing for common OCR errors in Thai numerals

### 6.2 Performance Optimization
- Process documents in batches of 10-20
- Use GPU acceleration if available (`AcceleratorDevice.CUDA`)
- Cache processed results to avoid re-processing

### 6.3 Data Quality
- Implement validation rules for financial data
- Cross-check balance sheet totals
- Flag documents requiring manual review

### 6.4 AI Agent Integration
- Expose REST API with structured query endpoints
- Implement semantic search on Thai text content
- Provide financial metric aggregation endpoints

---

## Sources

- [Docling GitHub Repository](https://github.com/docling-project/docling)
- [EasyOCR GitHub Repository](https://github.com/JaidedAI/EasyOCR)
- [Docling Documentation](https://www.docling.ai/)
- [Thai OCR with EasyOCR](https://www.jaided.ai/easyocr/)
- [IBM Granite-Docling Announcement](https://www.ibm.com/new/announcements/granite-docling-end-to-end-document-conversion)
